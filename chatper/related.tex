\section{Related Work}
% \subsection{Web-based Visualization Authoring Tools}

% \subsection{Graph Visualization Authoring Tools}
Many libraries~\cite{DBLP:journals/vi/LiMSSZWZC18,mei2020datav,tableau} (tools, grammars, and frameworks) have been provided for implementing graph-based applications~\cite{wang2018graphprotector,pan2020exemplar}.
At the beginning, developers use conventional programming languages to construct graph visualization applications, such as C Sharp, C++, Javascript, and Python. Developers need to have proficient programming skills and understand the implementation mechanism~\cite{reas2003processing,reas2005processing}.
In the meantime, they also spend a lot of time developing and debugging. To make it easier for developers to program and develop quickly, visualization grammars and frameworks~\cite{lyra,lyra2,heer2010declarative} allows for detailed configurations on visual channels of visualizations such as D3.js~\cite{DBLP:journals/tvcg/BostockOH11}, ECharts~\cite{DBLP:journals/vi/LiMSSZWZC18}, Vega~\cite{DBLP:journals/tvcg/SatyanarayanRHH16}, and Vega-Lite~\cite{DBLP:journals/tvcg/SatyanarayanMWH17}.


However, when developers construct graph visualizations, they need to carefully select complex and different API to construct a graph, because these APIs are designed for full visualization rather than graph visualization applications. Cytoscape.js~\cite{DBLP:journals/bioinformatics/FranzLHDSB16}, Sigma.js~\cite{DBLP:journals/jossw/Coene18} and Gephi~\cite{DBLP:conf/icwsm/BastianHJ09} are used to construct graph visualizations. They encapsulate a series of API which are elaborated for the graph data. Developers can use them to construct graph visualizations quickly.
Moreover, large-scale data brings new challenges.
Some libraries~\cite{heer2005prefuse,wickham2011ggplot2,ren2014ivisdesigner} use Canvas to render elements.
However, these libraries can only render thousands of elements. To address this issue, PixiJS~\cite{graphicslearn}, P5~\cite{DBLP:journals/tvcg/LiM20} and Stardust~\cite{DBLP:journals/cgf/RenLH17} use GPU-based acceleration technology to render a large number of elements.
However, these GPU-based tools are also not designed for graph visualizations.
They still have redundancy and complex API that have nothing to do with graph visualizations. It leads to a decrease in rendering efficiency and an increase in learning costs.

\name targets on high-efficient visualization of large-scale node-link diagrams. It leverages a GPU-based visualization framework to improve the rendering performance, and design-friendly concise programming interfaces for efficient manipulation over graph elements.

% \subsection{graph Grammars and Frameworks}
% Many graph grammars and frameworks have been provided to developers for designing graph visualization applications.
% In the beginning, developers use conventional programming languages to construct graph visualization applications, such as C Sharp, C++, Javascript, and Python. Developers need to have proficient programming skills and understand the implementation mechanism.
% In the meantime, they also spend a lot of time developing and debugging. To make it easier for developers to program and develop quickly, visualization grammars and frameworks give granular control of visual channels of visualizations such as D3.js~\cite{DBLP:journals/tvcg/BostockOH11}, ECharts~\cite{DBLP:journals/vi/LiMSSZWZC18}, Vega~\cite{DBLP:journals/tvcg/SatyanarayanRHH16}, and Vega-Lite~\cite{DBLP:journals/tvcg/SatyanarayanMWH17}. Developers can use more concise tools to construct visualizations.


% However, when developers construct graph visualizations, they need to carefully select complex and different API to construct a graph, because these APIs are designed for full visualization rather than graph visualization applications. Cytoscape.js~\cite{DBLP:journals/bioinformatics/FranzLHDSB16}, sigmajs~\cite{DBLP:journals/jossw/Coene18} and Gephi~\cite{DBLP:conf/icwsm/BastianHJ09} are used to construct graph visualizations. They encapsulate a series of API which are elaborated for the graph data. Developers can use them to construct graph visualizations quickly.
% Moreover, large-scale data brings new challenges. These grammars and tools can only render thousands of elements. To address this issue, PixiJS~\cite{graphicslearn}, P5~\cite{DBLP:journals/tvcg/LiM20} and Stardust~\cite{DBLP:journals/cgf/RenLH17} used GPU-based acceleration technology to render a large number of elements.
% However, these GPU-based tools are also not designed for graph visualizations.
% They still have redundancy and complex API that have nothing to do with graph visualizations. It leads to a decrease in rendering efficiency and an increase in learning costs.

% Our \name focus on large-scale graph visualization. It uses a GPU-based rendering engine to support large-scale data and design-friendly concise programming interfaces for graph visualization construction.

% \subsection{GPU-based Visualization Rendering}




