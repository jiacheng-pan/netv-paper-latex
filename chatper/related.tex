\section{Related Work}
% \subsection{Web-based Visualization Authoring Tools}

% \subsection{Graph Visualization Authoring Tools}
Many libraries~\cite{DBLP:journals/vi/LiMSSZWZC18,mei2020datav,tableau} (tools, grammars, and frameworks) have been provided for graph-based applications~\cite{wang2018graphprotector,pan2020exemplar}.
At the beginning, developers use conventional programming languages to construct graph visualization applications, such as C Sharp, C++, Javascript, and Python. Developers need to have proficient programming skills and understand the implementation mechanism~\cite{reas2003processing,reas2005processing}.
In the meantime, they spend much time in developing and debugging. To make this process easier, visualization grammars and frameworks~\cite{lyra,lyra2,heer2010declarative} allows for detailed configurations on visual channels of visualizations. Representatives include D3.js~\cite{DBLP:journals/tvcg/BostockOH11}, ECharts~\cite{DBLP:journals/vi/LiMSSZWZC18}, Vega~\cite{DBLP:journals/tvcg/SatyanarayanRHH16}, and Vega-Lite~\cite{DBLP:journals/tvcg/SatyanarayanMWH17}.


However, developers still need to carefully select complex APIs to construct a graph, because APIs are designed for general-purposed visualization rather than graph visualization applications. Alternatively, graph visualization tools like Cytoscape.js~\cite{DBLP:journals/bioinformatics/FranzLHDSB16}, Sigma.js~\cite{DBLP:journals/jossw/Coene18} and Gephi~\cite{DBLP:conf/icwsm/BastianHJ09} design and implement specific features to ease the construction process. 

% Moreover, large-scale data brings new challenges.
% Some libraries~\cite{heer2005prefuse,wickham2011ggplot2,ren2014ivisdesigner} use Canvas to render elements.
% However, these libraries can only render thousands of elements. To address this issue, PixiJS~\cite{graphicslearn}, P5~\cite{DBLP:journals/tvcg/LiM20} and Stardust~\cite{DBLP:journals/cgf/RenLH17} use GPU-based acceleration technology to render a large number of elements.
% However, these GPU-based tools are also not designed for graph visualizations.
% They still have redundancy and complex API that have nothing to do with graph visualizations. It leads to a decrease in rendering efficiency and an increase in learning costs.

On the other hand, data size poses a great challenge in terms of efficiency. Some libraries [30, 31, 32] use canvas to draw visual elements, yielding a low performance. PixiJS~\cite{graphicslearn}, P5~\cite{DBLP:journals/tvcg/LiM20} and Stardust~\cite{DBLP:journals/cgf/RenLH17} utilize GPU-based technique to make it amenable for a large number of elements. However, they are not specifically designed for graph visualizations, and contain redundant APIs that are unnecessary for graph visualizations. There are much potential for enhancing the rendering efficiency. 

\name targets on high-efficient visualization of large-scale node-link diagrams. It leverages a GPU-based visualization framework to improve the rendering performance, and design-friendly concise programming interfaces for efficient manipulation over graph elements.

% \subsection{graph Grammars and Frameworks}
% Many graph grammars and frameworks have been provided to developers for designing graph visualization applications.
% In the beginning, developers use conventional programming languages to construct graph visualization applications, such as C Sharp, C++, Javascript, and Python. Developers need to have proficient programming skills and understand the implementation mechanism.
% In the meantime, they also spend a lot of time developing and debugging. To make it easier for developers to program and develop quickly, visualization grammars and frameworks give granular control of visual channels of visualizations such as D3.js~\cite{DBLP:journals/tvcg/BostockOH11}, ECharts~\cite{DBLP:journals/vi/LiMSSZWZC18}, Vega~\cite{DBLP:journals/tvcg/SatyanarayanRHH16}, and Vega-Lite~\cite{DBLP:journals/tvcg/SatyanarayanMWH17}. Developers can use more concise tools to construct visualizations.


% However, when developers construct graph visualizations, they need to carefully select complex and different API to construct a graph, because these APIs are designed for full visualization rather than graph visualization applications. Cytoscape.js~\cite{DBLP:journals/bioinformatics/FranzLHDSB16}, sigmajs~\cite{DBLP:journals/jossw/Coene18} and Gephi~\cite{DBLP:conf/icwsm/BastianHJ09} are used to construct graph visualizations. They encapsulate a series of API which are elaborated for the graph data. Developers can use them to construct graph visualizations quickly.
% Moreover, large-scale data brings new challenges. These grammars and tools can only render thousands of elements. To address this issue, PixiJS~\cite{graphicslearn}, P5~\cite{DBLP:journals/tvcg/LiM20} and Stardust~\cite{DBLP:journals/cgf/RenLH17} used GPU-based acceleration technology to render a large number of elements.
% However, these GPU-based tools are also not designed for graph visualizations.
% They still have redundancy and complex API that have nothing to do with graph visualizations. It leads to a decrease in rendering efficiency and an increase in learning costs.

% Our \name focus on large-scale graph visualization. It uses a GPU-based rendering engine to support large-scale data and design-friendly concise programming interfaces for graph visualization construction.

% \subsection{GPU-based Visualization Rendering}




